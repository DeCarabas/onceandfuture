Notes on Building:
==================

Right now our Dockerfile builds Mono from an alpha source snapshot, in order
to get TLS 1.2 working properly. This is *S L O W*, and large, but it
works. The alternatives are:

1. Base everything on dotnet core. This makes for a smaller and lighter
   Docker image and maybe a better runtime environment, but I need
   System.Drawing, which is not part of .net core 1.1.

2. Install from Alpha packages. This would be way faster and smaller than
   building from source, but the problem with this is that I wind up without
   the btls-cert-sync program, which I need in order to bring in the root
   certificates for the new TLS stack.

So we're doing what we can. Just set aside an hour for building the Docker
image. At least it's 100% automated.

Todo:
=======

- When a site is unresponsive and timing out, it makes the entire refresh
  period take FOREVER, and there's no understanding of why. A better refresh
  status or something would be useful.

- Refresh is super slow on the docker image.

UI:
- Account creation flow
- Account settings view
- Change email address option
- Add/remove river sets
- Sign Out
- Update Progress
- More/less UX is jarring.
- Import/export OPML
- Font size for bubbles is wrong.
- When removing a feed, remove from sources.

Back-end Stuff:
- Cache health check results; currently pinging the QA instance very hard.
- Cancellation tokens everywhere
- Single HttpClient (or factory) everywhere
- Measure things:
  - Number of concurrent HTTP connections
  - Latencies of various things
- Replace inline log with static log method
- Login cookie cache scrubber
- Max request size
- Limit on HTTP response sizes, strong timeouts
  - Remember that attackers dictate URLs.

Tests:
- Some known feed snapshots, check to make sure rivers match. (Make sure
  to mock the web and return fake images, &c.)

Shipping:
- Re-pack font awesome fonts
- Use packed/minified/precompiled source if it exists
- Implement ATOM cache timeout and RSS skip hours and the like to poll more
  intelligently.
- Clip titles that are too long. (Because seriously.)

Later:
- Extract enclosures and the like, store locally (in the DB) and present them
  in the river. (Then do UI work to expose audio enclosures and the like.)
- Trim rivers that get too big

Far future:
- For the future, we'll probably need options on individual feeds for
  processing to make them better. It is possible to over-engineer this so be
  careful.
- Implement pubsubhubbub?
